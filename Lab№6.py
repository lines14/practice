#!/usr/bin/env python
# coding: utf-8

# In[23]:


print('\nЗадание №1, вариант №1:\n')

# После первой попытки понять механизм работы рекурсии
# создала функцию в функции, идеологически больше похожую
# на цикл while из лабораторной работы №2
# (нужно было задать переменную factorial для перезаписи функцией,
# чего не удалось сделать в глобальной области видимости):

def f(n):
    
    # Задаём переменную для перезаписи рекурсией и спускаем её 
    # в качестве аргумента во внутреннюю рекурсивную функцию:
    
    value_exit = 0
    factorial = 1
    
    def f_1(n, factorial):
        
        # Задаём условие выхода из рекурсии
        # при равенстве n нулю:
        
        if n!=0:
            factorial = factorial*n
            n = n-1
            f_1(n, factorial)
            
        # Переопределяем заданную ранее переменную value_exit 
        # для возвращения результата операций во внешнюю функцию 
        # в связи с невозможностью вернуть значение factorial
        # (почему-то возвращает None):
            
        else:
            nonlocal value_exit
            value_exit = factorial
            return value_exit
     
    # Обращаемся ко внутренней рекурсивной функции
    # и возвращаем результат её работы во внешнюю:
    
    f_1(n, factorial)
    return value_exit

# Передаём в заданную функцию вводимое пользователем натуральное число n
# и обращаемся к ней:

n = float(input('Введите натуральное число: '))

if not float.is_integer(n):
    print('\nВведённое число не является целым, вычислить факториал невозможно.')
    
elif n<0:
    print('\nВведённое число является отрицательным, вычислить факториал невозможно')
    
else:
    n = int(n)
    print(f'\nФакториал n! числа {n} равняется: {f(n)}')


# In[24]:


print('\nЗадание №1, вариант №2:\n')

# Для второго варианта с "полноценным" вычислением факториала рекурсией
# пришлось вдохновляться дополнительными обучающими ресурсами
# в интернете в связи с нехваткой материала на тему рекурсий в лекции:

def f(n):
    
    # Задаём условие достижения необходимой "глубины" рекурсии при равенстве n нулю:
    
    if n==0:
        return 1
    
    # При последовательном "проваливании" кода в рекурсивные функции со значениями "n-1", 
    # следующие за ними в теле условия else операции "приостанавливаются",
    # а после достижения заданной "глубины" рекурсии начинают последовательно выполняться
    # "в стиле цикла", перезаписывая переменные и возвращая нам по итогу значение факториала:
    
    else:
        m = f(n-1)
        x = n*m
        return x

# Передаём в заданную функцию вводимое пользователем натуральное число n
# и обращаемся к ней:

n = float(input('Введите натуральное число: '))

if not float.is_integer(n):
    print('\nВведённое число не является целым, вычислить факториал невозможно.')
    
elif n<0:
    print('\nВведённое число является отрицательным, вычислить факториал невозможно')
    
else:
    n = int(n)
    print(f'\nФакториал n! числа {n} равняется: {f(n)}')


# In[14]:


print('\nЗадание №2:\n')

# Импортируем функцию из модуля для получения случайных
# целых чисел, которыми наполняем два исходных списка:

from random import randint as rd

list_1 = []
list_2 = []

for i in range(5):
    list_1.append(rd(0, 20))
    list_2.append(rd(0, 20))

print(f'Генерируем список №1 из случайных целых чисел: {list_1}')
print(f'Генерируем список №2 из случайных целых чисел: {list_2}')

# Создаём итоговый список квадратов разностей 
# между соответствующими элементами исходных списков:

list_3 = list(map(lambda i, j: (i-j)**2, list_1, list_2))
print(f'Получаем список квадратов разностей между\nсоответствующими элементами списка №1 и списка №2: {list_3}')


# In[ ]:




